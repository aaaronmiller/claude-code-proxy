"""
Environment File Utilities

Shared module for all TUI components to properly update .env files.
Ensures keys are REPLACED (not duplicated) when already present.
"""

import os
from pathlib import Path
from typing import Dict, Optional, List, Tuple
from rich.console import Console

console = Console()

# Default .env path relative to project root
PROJECT_ROOT = Path(__file__).parent.parent.parent
DEFAULT_ENV_PATH = PROJECT_ROOT / ".env"


def update_env_values(
    updates: Dict[str, Optional[str]],
    env_path: Optional[Path] = None,
    verbose: bool = True
) -> bool:
    """
    Properly update .env file by replacing existing keys or adding new ones.
    
    This is the CANONICAL way to update .env files in this project.
    All TUI components should use this function.
    
    Args:
        updates: Dict of key -> value. If value is None, key is commented out.
        env_path: Path to .env file. Defaults to project root .env
        verbose: Print success message
        
    Returns:
        True on success, False on error
    """
    env_file = env_path or DEFAULT_ENV_PATH
    
    try:
        # Create file if doesn't exist
        if not env_file.exists():
            with open(env_file, "w") as f:
                f.write("# Claude Code Proxy Configuration\n")
                f.write("# Generated by env_utils\n\n")
        
        # Read existing content
        with open(env_file, "r") as f:
            lines = f.readlines()
        
        new_lines = []
        processed_keys = set()
        
        # Process existing lines - replace matching keys
        for line in lines:
            line_stripped = line.strip()
            
            # Preserve comments and empty lines
            if not line_stripped or line_stripped.startswith("#"):
                new_lines.append(line)
                continue
            
            # Parse KEY=VALUE (handle optional 'export' prefix)
            if "=" in line_stripped:
                key_part = line_stripped.split("=", 1)[0].strip()
                clean_key = key_part.replace("export ", "")
                
                if clean_key in updates:
                    new_val = updates[clean_key]
                    processed_keys.add(clean_key)
                    
                    if new_val is None:
                        # Disable: Comment out the line
                        new_lines.append(f"# {line_stripped}  # Disabled\n")
                    else:
                        # Replace with new value
                        # Preserve 'export' prefix if originally present
                        prefix = "export " if key_part.startswith("export") else ""
                        # Quote values with spaces, preserve existing quote style
                        if " " in str(new_val) and not new_val.startswith('"'):
                            new_val = f'"{new_val}"'
                        new_lines.append(f"{prefix}{clean_key}={new_val}\n")
                else:
                    # Keep unchanged
                    new_lines.append(line)
            else:
                new_lines.append(line)
        
        # Add new keys that weren't in the file
        added_keys = []
        for key, val in updates.items():
            if key not in processed_keys and val is not None:
                # Ensure blank line before new keys if needed
                if new_lines and new_lines[-1].strip():
                    new_lines.append("\n")
                # Quote values with spaces
                if " " in str(val) and not val.startswith('"'):
                    val = f'"{val}"'
                new_lines.append(f"{key}={val}\n")
                added_keys.append(key)
        
        # Write back
        with open(env_file, "w") as f:
            f.writelines(new_lines)
        
        if verbose:
            updated = [k for k in processed_keys if updates.get(k) is not None]
            disabled = [k for k in processed_keys if updates.get(k) is None]
            
            if updated:
                console.print(f"[green]✓[/] Updated: {', '.join(updated)}")
            if added_keys:
                console.print(f"[green]✓[/] Added: {', '.join(added_keys)}")
            if disabled:
                console.print(f"[yellow]○[/] Disabled: {', '.join(disabled)}")
        
        return True
        
    except Exception as e:
        console.print(f"[red]✗[/] Error updating {env_file}: {e}")
        return False


def get_env_value(key: str, default: Optional[str] = None) -> Optional[str]:
    """
    Get environment value, checking both os.environ and .env file.
    
    Args:
        key: Environment variable name
        default: Default value if not found
        
    Returns:
        Value or default
    """
    # Check os.environ first (runtime overrides)
    if key in os.environ:
        return os.environ[key]
    
    # Check .env file
    if DEFAULT_ENV_PATH.exists():
        try:
            with open(DEFAULT_ENV_PATH, "r") as f:
                for line in f:
                    line = line.strip()
                    if line.startswith("#") or "=" not in line:
                        continue
                    k, v = line.split("=", 1)
                    k = k.replace("export ", "").strip()
                    if k == key:
                        # Remove quotes if present
                        v = v.strip()
                        if v.startswith('"') and v.endswith('"'):
                            v = v[1:-1]
                        elif v.startswith("'") and v.endswith("'"):
                            v = v[1:-1]
                        return v
        except Exception:
            pass
    
    return default


def set_env_value(key: str, value: Optional[str], verbose: bool = True) -> bool:
    """
    Convenience function to set a single env value.
    
    Args:
        key: Environment variable name
        value: Value to set (None to disable)
        verbose: Print success message
        
    Returns:
        True on success
    """
    return update_env_values({key: value}, verbose=verbose)


def load_env_file() -> Dict[str, str]:
    """
    Load all values from .env file as a dictionary.
    
    Returns:
        Dict of key -> value
    """
    result = {}
    
    if not DEFAULT_ENV_PATH.exists():
        return result
    
    try:
        with open(DEFAULT_ENV_PATH, "r") as f:
            for line in f:
                line = line.strip()
                if line.startswith("#") or "=" not in line:
                    continue
                k, v = line.split("=", 1)
                k = k.replace("export ", "").strip()
                v = v.strip()
                # Remove quotes
                if (v.startswith('"') and v.endswith('"')) or \
                   (v.startswith("'") and v.endswith("'")):
                    v = v[1:-1]
                result[k] = v
    except Exception:
        pass
    
    return result


def backup_env_file() -> Optional[Path]:
    """
    Create backup of .env file before major changes.
    
    Returns:
        Path to backup file or None on error
    """
    if not DEFAULT_ENV_PATH.exists():
        return None
    
    try:
        import shutil
        from datetime import datetime
        
        backup_name = f".env.backup.{datetime.now().strftime('%Y%m%d_%H%M%S')}"
        backup_path = PROJECT_ROOT / backup_name
        shutil.copy(DEFAULT_ENV_PATH, backup_path)
        console.print(f"[dim]Backup created: {backup_name}[/]")
        return backup_path
    except Exception as e:
        console.print(f"[yellow]Warning: Could not create backup: {e}[/]")
        return None
